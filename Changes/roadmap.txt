AlmondShell Replicator Roadmap
==============================

Objective
---------
Fortify AlmondShell as the deployment-grade replication engine that forges and
injects new game and tooling instances on demand. Every build must ship with the
hooks required for AI-authored extensions, deterministic hot-swaps, and
self-auditing diagnostics so fresh clones remain trustworthy across platforms.

Guiding Tenets
--------------
1. Preserve the static, header-first core but expose injector recipes that allow
   scripted assembly of new launchers, editors, and mini-games.
2. Optimise for repeatable replication: every feature needs telemetry, logging,
   and rollback levers that automation can invoke without human babysitting.
3. Keep renderer, input, and scripting backends pluggable so the runtime can
   re-target clones for desktop, headless, or cloud streaming contexts.
4. Treat the companion co-processor as a first-class collaborator by providing
   event feeds and configuration surfaces it can mutate safely.

Execution Phases
----------------

Phase 1 – Genome Audit & Deterministic Bootstraps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Lock down the core artefacts that define an AlmondShell clone and make
sure every platform reproduces them bit-for-bit.
- [ ] Produce canonical CMake and vcpkg presets that emit identical layout and
      version metadata for Windows, Linux, and macOS.
- [ ] Bundle a "replicator manifest" that lists configuration flags, renderer
      selections, and seed data required to rehydrate the default launcher.
- [ ] Script a bootstrap verification job that compiles the engine, spins up the
      default scene headlessly, and exports telemetry hashes for comparison.
- [ ] Ship container images (WSL + Linux) that run the bootstrap verifier and
      publish the resulting artefacts for downstream clones.

Phase 2 – Adaptive Runtime Spine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Make hot reload, task orchestration, and cross-context rendering stable
under mutation storms initiated by automation.
- [ ] Instrument the task scheduler with structured events so the co-processor
      can detect starvation, recursion, or deadlocks.
- [ ] Harden renderer swaps by capturing frame graphs before/after an injector
      rewires contexts and diffing the telemetry for regressions.
- [ ] Expand the scripting pipeline with sandboxed execution and parallel
      compile queues so batches of `.ascript.cpp` files can reload without
      freezing the UI.
- [ ] Export health dashboards that enumerate active contexts, window state, and
      hot reload history for each clone.

Phase 3 – Interaction Fabric & Input Genetics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Unify input, UI, and networking layers so replicas inherit the same
multiplayer-ready control surfaces.
- [ ] Finalise cross-backend input abstraction with remapping profiles and
      virtual device descriptors stored in the replicator manifest.
- [ ] Layer gamepad, keyboard, and pointer telemetry into the retrieval store so
      automation can observe behavioural drift between clones.
- [ ] Deliver a metrics overlay (frame time, job queue depth, memory usage) that
      toggles via scripting API and exposes structured logs.
- [ ] Integrate save/load checkpoints for each bundled scenario, keeping the
      state machine portable across injected builds.

Phase 4 – Automation & Release Orchestration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Provide one-click pipelines that the co-processor can trigger to clone,
verify, package, and ship AlmondShell variants.
- [ ] Add cross-platform scripts for build, test, package, and release flows
      (POSIX + PowerShell) that accept replicator manifest overrides.
- [ ] Stand up CI matrices for all supported toolchains, including crash-dump
      capture and symbol uploads for post-mortem replication.
- [ ] Generate API reference docs from headers and host them alongside the
      manifest catalogue.
- [ ] Automate release candidate creation: package artefacts, sign binaries, and
      emit checksums verified by the bootstrap job.

Acceptance Signals
------------------
- Bootstrap verifier succeeds on every supported platform with identical hashes
  and artefact manifests.
- Regression coverage spans rendering, scripting, input, networking, and updater
  flows, with telemetry available for the co-processor to inspect.
- Documentation empowers new contributors—or automated replicas—to build,
  extend, and deploy the engine in a single working session.

Next-Step Prompt
----------------
"You are piloting AlmondShell through Phase {N} of the replicator roadmap.
Inspect the remaining tasks, assemble a PR-sized strike list, execute it, and
report back with diffs, telemetry hashes, and documentation updates."


AlmondAI Runtime Evolution Roadmap
==================================

Objective
---------
Transform the AlmondAI runtime into a self-replicating, AI-injected orchestration
hub that continuously drafts, tests, and deploys new agents, games, and tooling
cells while remaining observable and safe to iterate on.

Guiding Tenets
--------------
1. Keep the modular header/implementation split intact but annotate each module
   with injector metadata so replicas know how to stitch components together.
2. Make every long-running service measurable: telemetry must reveal ingestion,
   training, mutation, and deployment state to both humans and the co-processor.
3. Treat the Model Context Protocol bridge as the canonical surface for
   automation and ensure every new capability is scriptable through MCP.
4. Close the loop between compiler diagnostics, scripted tests, and transcript
   ingestion so the runtime can evolve itself without manual babysitting.

Execution Phases
----------------

Phase 1 – Cartography & Observatory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Document the full runtime topology and expose enough instrumentation to
watch a replica grow from zero to operational.
- [ ] Catalogue every MCP method, payload, and response contract in
      `AlmondAI/docs`, linking to the corresponding headers and source files.
- [ ] Map persistent artefacts (weights, vocab, adapters, telemetry logs,
      manifests) and document retention, rotation, and replication guidelines.
- [ ] Produce sequence diagrams for ingest, train, generate, evaluate, and
      injection flows, highlighting where the co-processor can intervene.
- [ ] Build a smoke journey that boots the runtime, exercises `model.generate`,
      `ingest.step`, `train.step`, and emits a replication manifest snapshot.

Phase 2 – Mutation-Ready Learning Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Upgrade training and retrieval subsystems so they withstand continuous
mutation and parallel replication.
- [ ] Swap the squared-error loss for cross-entropy over sampled token
      distributions, with unit tests covering gradient application edge cases.
- [ ] Persist retrieval index metadata (including semantic tags) to disk and
      reload it on startup so replicas inherit contextual memory.
- [ ] Introduce adapter checkpointing with lineage tracking and health metrics
      surfaced via MCP.
- [ ] Parallelise `trainer.fit` batch work while guarding log streams against
      contention and surfacing progress telemetry.

Phase 3 – Service Mesh & Injection Controls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Provide production-friendly controls for inference surfaces and
outbound teacher federations.
- [ ] Add rate limits, quotas, and tenant-aware throttles to `Service::run` and
      expose them via MCP configuration commands.
- [ ] Support streaming `model.generate` responses with incremental token
      callbacks and structured stream events.
- [ ] Expand `chat::Backend` with retry/backoff policies, uniform tracing, and
      policy-governed failure envelopes.
- [ ] Harden the GPT teacher bridge with circuit breakers, redaction pipelines,
      and structured error payloads fed back into the mutation planner.

Phase 4 – Evaluation Matrix & Ops Tooling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Keep replicas accountable and easy to iterate on once deployed.
- [ ] Build an evaluation harness that replays curated datasets and compares
      weight revisions, surfacing regressions through MCP reports.
- [ ] Export metrics to Prometheus-compatible endpoints and bundle Grafana
      dashboards for the default deployment.
- [ ] Generate API documentation from headers and publish alongside the runtime
      cartography packet.
- [ ] Deliver CLI utilities for seeding datasets, rotating adapters, and purging
      artefacts—each emitting replication manifest updates.

Phase 5 – Release & Propagation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**Goal:** Package the runtime so new replicas can be spawned automatically and
safely across environments.
- [ ] Produce container images and reproducible build scripts for Linux and
      Windows, including GPU-enabled variants when available.
- [ ] Create signed release bundles that embed replication manifests, bootstrap
      smoke logs, and compatibility matrices.
- [ ] Document upgrade and downgrade choreography for live replicas, including
      rollback triggers and telemetry checks.
- [ ] Run dry-run promotions that build, test, sign, and deploy to a staging
      fleet managed entirely through MCP commands.

Acceptance Signals
------------------
- Runtime telemetry exposes end-to-end health for ingestion, training, and
  deployment pipelines.
- Replicas inherit memory, adapters, and policies without manual file wrangling.
- Release tooling produces reproducible artefacts accompanied by verified smoke
  logs and manifest fingerprints.

Next-Step Prompt
----------------
"You are guiding the AlmondAI runtime through Phase {N}. Harvest outstanding
tasks, execute the next viable slice, and return with linked diffs, telemetry,
replication manifests, and MCP command transcripts."
